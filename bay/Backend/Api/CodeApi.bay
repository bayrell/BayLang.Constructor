/*!
 *  BayLang Constructor
 */

namespace BayLang.Constructor.Backend.Api;

use Runtime.fs;
use Runtime.Exceptions.ApiError;
use Runtime.Exceptions.ItemNotFound;
use Runtime.Exceptions.RuntimeException;
use Runtime.Web.BaseApi;
use Runtime.Web.Annotations.ApiMethod;
use BayLang.Exceptions.ParserUnknownError;
use BayLang.Helper.Module;
use BayLang.Helper.Project;


class CodeApi extends BaseApi
{
	Project project;
	
	
	/**
	 * Returns api name
	 */
	static string getApiName() => "baylang.constructor.code";
	
	
	/**
	 * Action before
	 */
	async void onActionBefore()
	{
		/* Get project */
		string project_id = this.post_data.get("project_id");
		this.project = await Project::readProject(
			fs::join([@.env("constructor_path"), "projects", project_id])
		);
		if (not this.project)
		{
			throw new ApiError(new ItemNotFound(project_id, "Project"));
		}
		
		/* Load project */
		await this.project.load();
	}
	
	
	/**
	 * Returns files
	 */
	@ApiMethod
	async void getFiles()
	{
		Collection items = [];
		string file_path = this.post_data.get("file_path");
		string project_path = this.project.getPath();
		string folder_path = fs::join([project_path, file_path]);
		
		/* File not exists */
		if (not await fs::isFolder(folder_path))
		{
			throw new ApiError(new ItemNotFound(file_path, "Folder"));
		}
		
		/* Get items */
		Collection<string> files = await fs::listDir(folder_path);
		for (int i=0; i<files.count(); i++)
		{
			string item_name = files.get(i);
			string item_path = fs::join([folder_path, item_name]);
			string item_kind = "";
			
			if (await fs::isFile(item_path)) item_kind = "file";
			else if (await fs::isDir(item_path)) item_kind = "dir";
			
			items.push({
				"kind": item_kind,
				"file_name": item_name,
				"file_path": fs::join([file_path, item_name]),
			});
		}
		
		/* Result */
		this.success({
			"data":
			{
				"items": items,
			}
		});
	}
	
	
	/**
	 * Returns file content
	 */
	@ApiMethod
	async void getContent()
	{
		string file_path = this.post_data.get("file_path");
		string project_path = this.project.getPath();
		string file_full_path = fs::join([project_path, file_path]);
		
		/* File not exists */
		if (not await fs::isFile(file_full_path))
		{
			throw new ApiError(new ItemNotFound(file_path, "File"));
		}
		
		/* Read file */
		string content = await fs::readFile(file_full_path);
		
		/* Result */
		this.success({
			"data":
			{
				"file_path": file_path,
				"content": content,
			}
		});
	}
	
	
	/**
	 * Save file
	 */
	@ApiMethod
	async void saveContent()
	{
		string file_path = this.post_data.get("file_path");
		string project_path = this.project.getPath();
		string file_full_path = fs::join([project_path, file_path]);
		
		/* Read file */
		string content = this.post_data.get("content");
		await fs::saveFile(file_full_path, content);
		
		/* Compile file */
		Module module = this.project.findModuleByFileName(file_full_path);
		if (module)
		{
			/* Init module */
			await module.init();
			
			/* Compile file */
			string relative_src_file_path = module.getRelativeSourcePath(file_full_path);
			if (relative_src_file_path)
			{
				bool is_allow = module.checkAllow(relative_src_file_path);
				bool is_exclude = module.checkExclude(relative_src_file_path);
				if (is_allow and not is_exclude)
				{
					try
					{
						await module.compile(relative_src_file_path);
					}
					catch (ParserUnknownError e)
					{
						string error_str = e.getErrorMessage();
						string line = e.getErrorLine();
						string pos = e.getErrorPos();
						if (line != -1)
						{
							error_str ~= " at Ln:" ~ line ~ ( (pos != "") ? ", Pos:" ~ pos : "" );
						}
						throw new ApiError(new RuntimeException(error_str));
					}
				}
			}
		}
		
		/* Result */
		this.success({
			"data":
			{
				"file_path": file_path,
			}
		});
	}
}