/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayLang.Constructor.Frontend.Code;

use Runtime.lib;
use Runtime.ApiResult;
use Runtime.BaseModel;
use Runtime.Method;
use Runtime.Serializer;
use Runtime.Serializer.ObjectType;
use Runtime.Web.RenderContainer;
use Runtime.Widget.ResultModel;
use Runtime.Widget.Button.ButtonModel;
use Runtime.Widget.ContextMenu.ContextMenuMessage;
use Runtime.Widget.ContextMenu.ContextMenuModel;
use Runtime.Widget.Dialog.ConfirmDialogModel;
use Runtime.Widget.Dialog.DialogModel;
use Runtime.Widget.Dialog.DialogMessage;
use Runtime.Widget.Dialog.PromptDialogModel;
use Runtime.Widget.Tree.TreeMessage;
use Runtime.Widget.Tree.TreeModel;
use BayLang.Constructor.Frontend.Code.CodeEditor;
use BayLang.Constructor.Frontend.Code.TreeItem;
use BayLang.Constructor.Frontend.Code.TreeWidget;
use BayLang.Constructor.Frontend.Code.Commands.CommandInterface;
use BayLang.Constructor.Frontend.Code.Commands.Copy;
use BayLang.Constructor.Frontend.Code.Commands.CreateFile;
use BayLang.Constructor.Frontend.Code.Commands.CreateFolder;
use BayLang.Constructor.Frontend.Code.Commands.Paste;
use BayLang.Constructor.Frontend.Code.Commands.Remove;
use BayLang.Constructor.Frontend.Code.Commands.Rename;


class CodeEditorModel extends BaseModel
{
	string component = classof CodeEditor;
	string copy_past_kind = "";
	string copy_past_path = "";
	ConfirmDialogModel confirm_dialog = null;
	PromptDialogModel prompt_dialog = null;
	TreeModel tree = null;
	TreeItem selected_tab = null;
	Collection<TreeItem> tabs = [];
	ResultModel save_result = null;
	ContextMenuModel context_menu = null;
	Map<CommandInterface> commands = null;
	
	
	/**
	 * Serialize object
	 */
	void serialize(Serializer serializer)
	{
		parent(serializer);
		serializer.addType("tree", new ObjectType{
			"class_name": classof TreeModel,
		});
	}
	
	
	/**
	 * Init widget settings
	 */
	void initWidget(Dict params)
	{
		parent(params);
		
		/* Init commands */
		this.commands = {
			"create_file": new CreateFile(this, "file"),
			"create_folder": new CreateFolder(this, "folder"),
			"remove": new Remove(this),
			"rename": new Rename(this),
			"copy": new Copy(this, "copy"),
			"cut": new Copy(this, "cut"),
			"paste": new Paste(this),
		};
		this.commands.set("delete", this.commands.get("remove"));
		
		/* Save result */
		this.save_result = this.createWidget(classof ResultModel);
		
		/* Confirm dialog */
		this.confirm_dialog = this.createWidget(classof ConfirmDialogModel);
		this.confirm_dialog.addEventListener("confirm", new Method(this, "onDialogConfirm"));
		
		/* Prompt dialog */
		this.prompt_dialog = this.createWidget(classof PromptDialogModel);
		this.prompt_dialog.addEventListener("confirm", new Method(this, "onDialogConfirm"));
		
		/* Context menu */
		this.context_menu = this.createWidget(classof ContextMenuModel, {
			"items":
			[
				{
					"label": "Create file",
					"key": "create_file",
				},
				{
					"label": "Create folder",
					"key": "create_folder",
				},
				{
					"label": "Rename",
					"key": "rename",
				},
				{
					"label": "Cut",
					"key": "cut",
				},
				{
					"label": "Copy",
					"key": "copy",
				},
				{
					"label": "Paste",
					"key": "paste",
				},
				{
					"label": "Delete",
					"key": "delete",
				},
			],
		});
		this.context_menu.addEventListener("clickItem", new Method(this, "onContextMenuItemClick"));
		
		/* Create Tree */
		this.tree = this.createWidget(classof TreeModel, {
			"component": classof TreeWidget,
			"dnd": false,
			"icons": true,
			"context_menu": this.context_menu,
			"context_menu_render": true,
		});
		this.tree.addEventListener("selectItem", new Method(this, "onTreeSelectItem"));
		this.tree.addEventListener("contextMenu", new Method(this, "onTreeContextMenu"));
		this.tree.root = new TreeItem
		{
			"open": true,
		};
	}
	
	
	/**
	 * Build title
	 */
	void buildTitle(RenderContainer container)
	{
		this.layout.setPageTitle("Code editor");
	}
	
	
	/**
	 * Load data
	 */
	async void loadData(RenderContainer container)
	{
		await parent(container);
		
		/* Load root */
		await this.loadItems(this.tree.root);
	}
	
	
	/**
	 * Remove tab
	 */
	void selectTab(TreeItem item)
	{
		this.selected_tab = item;
	}
	
	
	/**
	 * Add tab
	 */
	void addTab(TreeItem item)
	{
		this.tabs.push(this.tree.selected_item);
	}
	
	
	/**
	 * Remove tab
	 */
	void removeTab(TreeItem item)
	{
		this.tabs.removeItem(item);
		this.save_result.clear();
		if (this.selected_tab == item) this.selected_tab = null;
	}
	
	
	/**
	 * Tree context menu
	 */
	void onTreeContextMenu(TreeMessage message)
	{
		TreeItem item = message.item;
		this.tree.context_menu.items.each(
			void (Dict params) use (item)
			{
				string key = params.get("key");
				
				/* Create */
				if (key == "create_folder" or key == "create_file")
				{
					if (item == null) params.set("hidden", false);
					else params.set("hidden", item.kind == "file");
				}
				
				/* Copy */
				if (key == "copy" or key == "cut" or key == "rename" or key == "delete")
				{
					if (item == null)
					{
						params.set("hidden", true);
					}
					else
					{
						params.set("hidden", false);
					}
				}
				
				/* Paste */
				if (key == "paste")
				{
					if (
						this.copy_past_path == "" or
						item != null and rs::dirname(this.copy_past_path) == item.file_path or
						item == null and rs::dirname(this.copy_past_path) == ""
					)
					{
						params.set("hidden", true);
					}
					else
					{
						params.set("hidden", false);
					}
				}
			}
		);
	}
	
	
	/**
	 * Context menu item click
	 */
	async void onContextMenuItemClick(ContextMenuMessage message)
	{
		string item_key = message.item.get("key");
	
		/* Hide context menu */
		message.model.hide();
		
		/* Run command */
		if (this.commands.has(item_key))
		{
			CommandInterface command = this.commands.get(item_key);
			await command.onContextMenuItemClick(message);
		}
	}
	
	
	/**
	 * Confirm dialog
	 */
	async void onDialogConfirm(DialogMessage message)
	{
		/* Run command */
		if (this.commands.has(message.model.action))
		{
			CommandInterface command = this.commands.get(message.model.action);
			await command.onDialogConfirm(message);
		}
	}
	
	
	/**
	 * Select item
	 */
	async void onTreeSelectItem(TreeMessage message)
	{
		TreeItem selected_item = this.tree.selected_item;
		if (not selected_item) return;
		if (message.kind != "click") return;
		if (selected_item.kind == "dir")
		{
			await this.loadItems(selected_item);
			selected_item.open = not selected_item.open;
		}
		else if (selected_item.kind == "file")
		{
			if (this.tabs.indexOf(selected_item) == -1)
			{
				this.addTab(selected_item);
				this.selectTab(selected_item);
				await this.loadFileContent(selected_item);
			}
			else
			{
				this.selectTab(selected_item);
			}
		}
	}
	
	
	/**
	 * Save file
	 */
	async void save()
	{
		if (not this.selected_tab) return;
		
		this.save_result.setWaitMessage();
		
		string content = this.selected_tab.code_editor.ref.getValue();
		ApiResult res = await this.layout.sendApi({
			"api_name": "baylang.constructor.code",
			"method_name": "save",
			"data": {
				"file_path": this.selected_tab.file_path,
				"content": content,
			}
		});
		
		this.save_result.setApiResult(res);
	}
	
	
	/**
	 * Load file content
	 */
	async void loadFileContent(TreeItem item)
	{
		/* Clear content */
		item.content = "";
		item.is_loaded = true;
		
		/* Send request */
		ApiResult res = await this.layout.sendApi({
			"api_name": "baylang.constructor.code",
			"method_name": "getContent",
			"data": {
				"module_id": item.module_id,
				"file_path": item.file_path,
			}
		});
		
		/* Check is response is success */
		if (not res.isSuccess()) return;
		
		/* Set file content */
		item.content = res.data.get("content");
	}
	
	
	/**
	 * Load items
	 */
	async void loadItems(TreeItem item)
	{
		if (item.isLoaded()) return;
		
		ApiResult res = await this.layout.sendApi({
			"api_name": "baylang.constructor.code",
			"method_name": "getFiles",
			"data": {
				"module_id": item.module_id,
				"file_path": item.file_path,
			}
		});
		
		item.is_loaded = true;
		if (not res.isSuccess()) return;
		
		Collection result_items = res.data.get("items");
		
		/* Add items */
		for (int i=0; i<result_items.count(); i++)
		{
			Dict file = result_items.get(i);
			
			string label = file.get("file_name");
			TreeItem find_item = item.items.find(
				bool (TreeItem item) use (label) => item.label == label
			);
			
			/* Change item */
			if (find_item)
			{
				find_item.label = file.get("file_name")
				find_item.file_path = file.get("file_path")
			}
			
			/* Add item */
			else
			{
				item.items.push(new TreeItem{
					"kind": file.get("kind"),
					"label": file.get("file_name"),
					"file_path": file.get("file_path"),
					"module_id": item.module_id,
				});
			}
		}
		
		/* Remove items */
		for (int i=item.items.count() - 1; i >= 0; i--)
		{
			TreeItem find_item = item.items.get(i);
			TreeItem result_item = result_items.find(
				bool (Map item) use (find_item) => item.get("file_name") == find_item.label
			);
			if (not result_item)
			{
				item.items.remove(i);
			}
		}
		
		/* Sort items */
		item.items = item.items.sort(
			int (TreeItem a, TreeItem b)
			{
				if (a.kind == "dir" and b.kind == "file") return -1;
				if (a.kind == "file" and b.kind == "dir") return 1;
				return rs::compare(a.label, b.label);
			}
		);
	}
}