/*!
 *  BayLang Constructor
 */

namespace BayLang.Constructor.Frontend.Main;

use Runtime.lib;
use Runtime.Callback;
use Runtime.Math;
use Runtime.Serializer;
use Runtime.Web.BaseLayoutModel;
use Runtime.Web.BaseModel;
use Runtime.Web.BaseRoute;
use Runtime.Web.Component;
use Runtime.Web.RenderProvider;
use BayLang.Constructor.Frontend.Frame.Page;
use BayLang.Constructor.Frontend.Frame.PageModel;
use BayLang.Constructor.Frontend.Main.IndexPage;
use BayLang.Constructor.Frontend.Main.StructureModel;


class IndexPageModel extends BaseModel
{
	string component = classof IndexPage;
	var current_widget_path = null;
	var current_elem_box = null;
	var iframe = null;
	int widget_counter = 1;
	
	bool property_visible = true;
	string property_buttons_selected = "hierarchy";
	Collection property_buttons = [
		{
			"key": "hierarchy"
			"icon": "H",
			"label": "Hierarchy",
		},
		{
			"key": "property"
			"icon": "P",
			"label": "Property",
		},
	];
	
	StructureModel structure = null;
	
	
	/**
	 * Returns iframe layout
	 */
	BaseLayoutModel getFrameLayout() =>
		this.iframe ? this.iframe.contentWindow.app_layout : null;
	
	
	/**
	 * Returns page model
	 */
	BaseLayoutModel getFramePageModel() =>
		this.iframe ? this.iframe.contentWindow.app_layout.getPageModel() : null;
	
	
	/**
	 * Get widget
	 */
	BaseLayoutModel getWidget(Collection model_path) =>
		this.getFrameLayout().model(model_path)
	;
	
	
	/**
	 * Returns current widget
	 */
	BaseModel getCurrentWidget() => this.current_widget_path != null
		? this.getFrameLayout().model(this.current_widget_path)
		: null
	;
	
	
	/**
	 * Returns current widget path
	 */
	BaseModel getCurrentWidgetPath() => this.current_widget_path != null
		? rs::join("|", this.current_widget_path)
		: null
	;
	
	
	/**
	 * Constructor
	 */
	void constructor(Dict params = null)
	{
		parent(params);
		
		/* Add structure */
		this.structure = new StructureModel{
			"widget_name": "structure",
			"parent_widget": this,
		};
	}
	
	
	/**
	 * Route before
	 */
	async void onRouteBefore(BaseRoute route)
	{
	}
	
	
	/**
	 * Route after
	 */
	async void onRouteAfter(BaseRoute route)
	{
		this.layout.setPageTitle("Index page");
	}
	
	
	/**
	 * Process frontend data
	 */
	void processFrontendData(Serializer serializer, Map data)
	{
		/*serializer.process(this, "page_layout", data);*/
		parent(serializer, data);
	}
	
	
	/**
	 * Returns box styles by element
	 */
	static Dict getBoxStyles(var elem, string kind="")
	{
		int left, top, width, height;
		
		left = elem.offsetLeft;
		top = elem.offsetTop;
		width = elem.clientWidth - 1;
		height = elem.clientHeight - 1;
		
		Map box = {};
		box.set("left", rs::join(";", [
			"left: " ~ left ~ "px",
			"top: " ~ top ~ "px",
			"width: 1px",
			"height: " ~ height ~ "px",
		]));
		box.set("top", rs::join(";", [
			"left: " ~ left ~ "px",
			"top: " ~ top ~ "px",
			"width: " ~ width ~ "px",
			"height: 1px",
		]));
		box.set("right", rs::join(";", [
			"left: " ~ (left + width) ~ "px",
			"top: " ~ top ~ "px",
			"width: 1px",
			"height: " ~ height ~ "px",
		]));
		box.set("bottom", rs::join(";", [
			"left: " ~ left ~ "px",
			"top: " ~ (top + height) ~ "px",
			"width: " ~ width ~ "px",
			"height: 1px",
		]));
		box.set("box", rs::join(";", [
			"left: " ~ left ~ "px",
			"top: " ~ top ~ "px",
			"width: " ~ width ~ "px",
			"height: " ~ height ~ "px",
		]));
		
		return box;
	}
	
	
	/**
	 * Update current widget box
	 */
	void updateCurrentWidgetBox()
	{
		BaseModel widget = this.getCurrentWidget();
		if (widget == null) return;
		
		Component component = widget.getComponent();
		if (component == null) return;
		
		var elem = component.getRef("widget");
		if (rtl::exists(elem))
		{
			this.current_elem_box = static::getBoxStyles(elem, "iframe");
		}
	}
	
	
	/**
	 * Create component
	 */
	void createComponent(string class_name, Dict params) =>
		this.iframe.contentWindow.Runtime.rtl.newInstance(
			class_name, [params]
		)
	;
	
	
	/**
	 * Set current widget
	 */
	void setCurrentWidget(BaseModel widget)
	{
		this.current_widget_path = widget.getModelPath();
	}
	
	
	/**
	 * Update current widget
	 */
	void updateCurrentWidget(BaseModel widget)
	{
		if (widget == null)
		{
			this.current_widget_path = null;
			this.current_elem_box = null;
			return;
		}
		
		if (widget.getModelPathString() == this.getCurrentWidgetPath()) return;
		this.setCurrentWidget(widget);
		
		/* Update current widget box */
		RenderProvider::nextTick(void (){
			this.updateCurrentWidgetBox();
		});
	}
}