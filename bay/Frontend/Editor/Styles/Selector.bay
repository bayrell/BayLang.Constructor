/*!
 *  BayLang Constructor
 */

namespace BayLang.Constructor.Frontend.Editor.Styles;

use Runtime.BaseObject;
use BayLang.Constructor.Frontend.Editor.Styles.BackgroundImage;
use BayLang.Constructor.Frontend.Editor.Styles.StyleItem;
use BayLang.Constructor.Frontend.Editor.ComponentProcessor;
use BayLang.Constructor.Frontend.Editor.WidgetEditPageModel;
use BayLang.Exceptions.ParserUnknownError;
use BayLang.LangBay.ParserBay;
use BayLang.LangES6.TranslatorES6;
use BayLang.OpCodes.BaseOpCode;
use BayLang.OpCodes.OpHtmlStyle;


class Selector extends BaseObject
{
	WidgetEditPageModel parent_widget = null;
	OpHtmlStyle op_code = null;
	string selector_name = "";
	string source = "";
	string content = "";
	string css_ignore = "";
	Dict<StyleItem> styles = {};
	
	
	/**
	 * Translate CSS
	 */
	pure list translateCSS(ParserBay parser, TranslatorES6 translator, string source)
	{
		/* Parse source */
		BaseOpCode op_code = null;
		try
		{
			parser = parser::setContent(parser, source ~ "}");
			list res = parser.parser_html::readCssBody(parser);
			op_code = res.get(1);
		}
		catch (ParserUnknownError e)
		{
		}
		
		/* Translate source */
		if (not op_code) return "";
		
		Vector items = [];
		items.push("var content = \"\";");
		list res = translator.expression::Expression(translator, op_code);
		items.push("content += Runtime.rtl.toStr(" ~ res.get(1) ~ ");");
		
		string content = window.eval(rs::join("\n", items));
		return content;
	}
	
	
	/**
	 * Parse CSS
	 */
	pure list parseCSS(string content)
	{
		int content_sz = rs::strlen(content);
		int pos = 0;
		int start = 0;
		Collection styles = [];
		Collection css_ignore = [];
		while (pos < content_sz)
		{
			string ch = rs::charAt(content, pos);
			if (ch == "{")
			{
				int level = 1;
				if (start != pos)
				{
					string s = rs::substr(content, start, pos - start);
					Collection<string> items = rs::split(";", s);
					if (items.count() > 1)
					{
						styles.push(rs::join(";", items.slice(0, -1)) ~ ";");
					}
					css_ignore.push(rs::trim(items.last()));
				}
				start = pos;
				while (pos < content_sz and (
					ch != "}" and level == 0 or level > 0)
				)
				{
					pos = pos + 1;
					ch = rs::charAt(content, pos);
					if (ch == "{") level = level + 1;
					if (ch == "}") level = level - 1;
				}
				if (start != pos) css_ignore.push(rs::substr(content, start, pos - start + 1));
				if (pos < content_sz) start = pos + 1;
			}
			else
			{
				pos = pos + 1;
			}
		}
		if (start != pos) styles.push(rs::substr(content, start, pos - start));
		return
		[
			rs::join("", styles),
			rs::join("", css_ignore)
		];
	}
	
	
	/**
	 * Build content
	 */
	string buildContent()
	{
		Collection items = [];
		Collection keys = this.styles.keys().sort();
		for (int i=0; i<keys.count(); i++)
		{
			string key = keys.get(i);
			StyleItem value = this.styles.get(key);
			items.push(key ~ ": " ~ value.value);
		}
		items.push(this.css_ignore);
		string source = rs::join(";\n", items);
		return rs::trim(source);
	}
	
	
	/**
	 * Create style
	 */
	StyleItem createStyle(string key)
	{
		StyleItem value;
		if (key == "background-image") value = new BackgroundImage();
		else value = new StyleItem();
		value.key = key;
		return value;
	}
	
	
	/**
	 * Returns style
	 */
	StyleItem getStyle(string key)
	{
		if (not this.styles.has(key)) return null;
		return this.styles.get(key);
	}
	
	
	/**
	 * Set style value
	 */
	void setStyleValue(string key, string value)
	{
		/* Get CSS Value */
		StyleItem css_value = this.getStyle(key);
		if (not css_value)
		{
			css_value = this.createStyle(key);
			this.styles.set(css_value.key, css_value);
		}
		
		/* Set CSS Value */
		value = rs::trim(value);
		css_value.setValue(value);
		
		/* Update source */
		string source = this.buildContent();
		this.setContent(source, false);
	}
	
	
	/**
	 * Change style value
	 */
	void changeStyleValue(string key, string value)
	{
		/* Set CSS Value */
		this.setStyleValue(key, value);
		
		/* Update CSS */
		this.parent_widget.parent_widget.updateFrameCSS();
	}
	
	
	/**
	 * Parse styles
	 */
	void parseStyles()
	{
		string content = this.source;
		list res = static::parseCSS(content);
		
		/* CSS Values */
		this.styles = {};
		Collection items = rs::split(";", res.get(0));
		for (int i=0; i<items.count(); i++)
		{
			string item = items.get(i);
			Collection item_arr = rs::split(":", item);
			if (item_arr.count() == 2)
			{
				StyleItem value = this.createStyle(rs::trim(item_arr.get(0)));
				value.value = rs::trim(item_arr.get(1));
				this.styles.set(value.key, value);
			}
		}
		
		/* CSS Ignore */
		this.css_ignore = rs::trim(res.get(1));
	}
	
	
	/**
	 * Set content
	 */
	void setContent(string source, bool parse_styles = true)
	{
		ComponentProcessor component_processor = this.parent_widget.parent_widget.component_processor;
		ParserBay parser = component_processor.createParser();
		TranslatorES6 translator = component_processor.createTranslator();
		
		/* Parse CSS */
		string css_code = this.selector_name ~ "{" ~ source ~ "}";
		string content = static::translateCSS(parser, translator, css_code);
		
		/* Set content */
		this.source = source;
		this.content = content;
		if (parse_styles)
		{
			this.parseStyles();
		}
	}
}