/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayLang.Constructor.Frontend.Editor.Styles;

use BayLang.Constructor.Frontend.Editor.Manager.CodeStrategryInterface;
use BayLang.Constructor.Frontend.Editor.Manager.OpCodeStrategy;
use BayLang.Constructor.Frontend.Editor.Styles.Style;
use BayLang.Constructor.Frontend.Editor.Widget.Widget;
use BayLang.Constructor.Frontend.Editor.Widget.WidgetTag;
use BayLang.Constructor.Frontend.Editor.EditorPageModel;
use BayLang.OpCodes.BaseOpCode;
use BayLang.OpCodes.OpHtmlCSS;
use BayLang.OpCodes.OpHtmlStyle;
use Runtime.BaseObject;
use Runtime.DateTime;


class StyleManager extends BaseObject
{
	EditorPageModel page_model = null;
	CodeStrategryInterface code_strategy = null;
	Map<Style> items = {};
	Vector styles = [];
	int style_number = 0;
	
	
	/**
	 * Create object
	 */
	void constructor(EditorPageModel page_model)
	{
		parent();
		this.page_model = page_model;
	}
	
	
	/**
	 * Init styles
	 */
	void init()
	{
		if (not this.page_model.code_component.isLoaded()) return;
		
		/* Find style */
		this.code_strategy = new OpCodeStrategy(this.page_model.code_component.code);
		
		/* Add styles */
		Vector<OpHtmlCSS> items = this.code_strategy.getCSS();
		for (int i=0; i<items.count(); i++)
		{
			OpHtmlCSS op_code_css = items.get(i);
			this.addStyle(op_code_css);
		}
	}
	
	
	/**
	 * Add widget
	 */
	void addWidget(Widget widget, Map hash)
	{
		if (not (widget instanceof WidgetTag)) return;
		
		/* Add style */
		for (int i=0; i<widget.styles.items.count(); i++)
		{
			string class_name = widget.styles.items.get(i);
			if (hash.has(class_name)) continue;
			hash.set(class_name, true);
			this.styles.push(class_name);
		}
		
		/* Add widget */
		for (int i=0; i<widget.items.count(); i++)
		{
			this.addWidget(widget.items.get(i), hash);
		}
	}
	
	
	/**
	 * Refresh styles
	 */
	void refresh()
	{
		this.styles = [];
		Map hash = {};
		
		this.addWidget(this.page_model.widget, hash);
	}
	
	
	/**
	 * Update styles op code
	 */
	void updateOpCode()
	{
		Vector<OpHtmlCSS> items = [];
		for (int i=0; i<this.styles.count(); i++)
		{
			string class_name = this.styles.get(i);
			Style item = this.findStyle(class_name);
			if (not item) continue;
			if (rs::trim(item.content) == "") continue;
			
			OpHtmlCSS op_code = item.buildOpCode();
			items.push(op_code);
		}
		
		this.code_strategy.updateCSS(items);
	}
	
	
	/**
	 * Add style
	 */
	void addStyle(OpHtmlCSS op_code)
	{
		Style item = new Style();
		item.setSelector(op_code.selector);
		item.setOpCode(op_code);
		this.addItem(item);
	}
	
	
	/**
	 * Add style item
	 */
	void addItem(Style item)
	{
		this.items.set(item.getClassName(), item);
	}
	
	
	/**
	 * Find style by class name
	 */
	Style findStyle(string class_name)
	{
		if (not class_name) return null;
		
		/* Returns style */
		Style item = this.items.get(class_name);
		return item ? item : null;
	}
	
	
	/**
	 * Returns true if class name is exists
	 */
	bool exists(string class_name) => this.findStyle(class_name) != null;
	
	
	/**
	 * Copy class name
	 */
	void copy(string class_name, string new_name)
	{
		if (class_name == new_name) return;
		
		Style item = this.findStyle(class_name);
		if (not item) return;
		
		Style new_item = item.copy();
		new_item.setClassName(new_name);
		this.addItem(new_item);
	}
	
	
	/**
	 * Init style number
	 */
	void initStyleNumber(Widget widget)
	{
		Vector arr = [widget];
		while (arr.count() != 0)
		{
			Widget item = arr.first();
			arr.remove(0);
			
			if (item instanceof WidgetTag)
			{
				Vector<string> styles = item.styles.getStyles();
				for (int i=0; i<styles.count(); i++)
				{
					string class_name = styles.get(i);
					Vector class_name_arr = rs::split("-", class_name);
					if (class_name_arr.count() != 2) continue;
					
					/* Detect integer */
					int number = rtl::toInt(class_name_arr.last());
					if (number == 0) continue;
					
					/* Set number */
					if (number > this.style_number)
					{
						this.style_number = number;
					}
				}
			}
			
			arr.appendItems(item.items);
		}
	}
	
	
	/**
	 * Generate widget class name
	 */
	string generateWidgetClassName(string widget_name)
	{
		this.style_number = this.style_number + 1;
		return widget_name ~ "-" ~ this.style_number;
	}
	
	
	/**
	 * Generate unique class name
	 */
	string generateUniqueClassName(string widget_name)
	{
		int number = DateTime::now().timestamp() + rtl::random(1000, 9999);
		string widget_class_name = widget_name ~ "-" ~ rs::getCssHash(number);
		Style item = this.findStyle(widget_class_name);
		while (item != null)
		{
			number = number + 1;
			widget_class_name = widget_name ~ "-" ~ rs::getCssHash(number);
			item = this.findStyle(widget_class_name);
		}
		return widget_class_name;
	}
}